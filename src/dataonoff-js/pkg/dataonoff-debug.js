// commit ead9fa260cc075ac568f2e1c49c28541520be5af

//   Copyright 2012 keensoft
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

;(function() {

try {eval("var require = undefined,\n    define = undefined;\n\n(function () {\n    var modules = {};\n\n    function build(module) {\n        var factory = module.factory;\n        module.exports = {};\n        delete module.factory;\n        factory(require, module.exports, module);\n        return module.exports;\n    }\n\n    require = function (id) {\n        if (!modules[id]) {\n            throw \"module \" + id + \" not found\";\n        }\n        return modules[id].factory ? build(modules[id]) : modules[id].exports;\n    };\n\n    define = function (id, factory) {\n        if (modules[id]) {\n            throw \"module \" + id + \" already defined\";\n        }\n\n        modules[id] = {\n            id: id,\n            factory: factory\n        };\n    };\n\n    define.remove = function (id) {\n        delete modules[id];\n    };\n\n})();\n\n//Export for use in node\nif (typeof module === \"object\" && typeof require === \"function\") {\n    module.exports.require = require;\n    module.exports.define = define;\n}\n//@ sourceURL=lib/scripts/require.js")} catch(e) {console.log("exception: in lib/scripts/require.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff\", function(require, exports, module) {\nvar DataOnOffState = require(\"dataonoff/DataOnOffState\"),\n    DBQueue = require(\"dataonoff/DBQueue\"),\n    OperationsConsumer = require(\"dataonoff/OperationsConsumer\"),\n    EventHandler = require(\"dataonoff/EventHandler\");\n\n/**\n\n * Send operations and receive changes from a DataOnOff server.\n *\n * @constructor\n * @param {string}\n *            serverUrl Where the DataOnOff server is located.\n * @param {function}\n *            changesCallback Callback to be called when changes are recived from the server.\n * @param {function|null}\n *            errorCallback Callback to be called when anything goes wrong.\n * @returns a new DataOnOff instance\n */\nvar DataOnOff = function(dataOnOffConfig) {\n\tvar self = this;\n    console.info('Starting DataOnOff ...');\n\n    this.sendOperationToServer = function(operation) {\n        console.info('DataOnOff.sendOperationToServer: ' + JSON.stringify(operation));\n        this.operationsQueue.enqueue(operation);\n    };\n\n    this.manualServerSynchronization = function() {\n        this.sendOperationToServer(JSON.stringify({\n            \"operation\" : \"__MANUAL_SYNC__\"\n        }));\n    };\n\n    if (validDataOnOffConfig(dataOnOffConfig)) {\n        var retries = obtainRetriesSequence();\n        var event = declareEventHandlers();\n        var state = new DataOnOffState(event);\n        console.info('DeviceId: ' + JSON.stringify(dataOnOffConfig.deviceId));\n        this.operationsQueue = new DBQueue(dataOnOffConfig, event, state, retries);\n        var consumer = new OperationsConsumer(dataOnOffConfig, event, state, this);\n        this.operationsQueue.setConsumer(consumer);\n        // Start DataOnOff server sync\n        this.manualServerSynchronization();\n\n        // Schedule server synchronization\n        if (typeof dataOnOffConfig.scheduleServerSyncPeriod === 'number') {\n            var period = dataOnOffConfig.scheduleServerSyncPeriod;\n            console.info('Scheduling server synchoronization every ' + period / 1000 + ' seconds');\n            scheduleServerSync(period, event, state);\n        }\n    }\n\n    function declareEventHandlers() {\n        var event = {};\n        event.onLineServer = new EventHandler('onLineServer');\n        event.offLineServer = new EventHandler('offLineServer');\n        event.onLineNetwork = new EventHandler('onLineNetwork');\n        event.offLineNetwork = new EventHandler('offLineNetwork');\n        event.consumerReady = new EventHandler('consumerReady');\n        event.idle = new EventHandler('idle');\n        event.sending = new EventHandler('sending');\n        event.receiving = new EventHandler('sending');\n        event.retrying = new EventHandler('retrying');\n        event.serverSync = new EventHandler('serverSync');\n        event.processedOperation = new EventHandler('processedOperation');\n\n        event.onLineServer.addEventListener(dataOnOffConfig.onOnLineCallback);\n        event.offLineServer.addEventListener(dataOnOffConfig.onOffLineCallback);\n        event.idle.addEventListener(dataOnOffConfig.onIdleStatusCallback);\n        event.sending.addEventListener(dataOnOffConfig.onSendingOperationCallback);\n        event.receiving.addEventListener(dataOnOffConfig.onReceivingChangesCallback);\n        event.retrying.addEventListener(dataOnOffConfig.onRetryingChangesCallback);\n        event.processedOperation.addEventListener(dataOnOffConfig.onProcessedOperation);\n\n        // Event translator from Cordova events to ours one\n        if (window.cordova) {\n            document.addEventListener(\"online\", function() {\n                event.onLineNetwork.fireEvent();\n            }, false);\n            document.addEventListener(\"offline\", function() {\n                event.offLineNetwork.fireEvent();\n            }, false);\n        } else {\n            // console.debug('Cordova events not avilable');\n        }\n\n        return event;\n    }\n\n    function obtainRetriesSequence() {\n        var var1 = 0;\n        var var2 = 500;\n        var var3;\n\n        var retries = [];\n        do {\n            var3 = var1 + var2;\n            var1 = var2;\n            var2 = var3;\n            if (var3 < dataOnOffConfig.retryFaliledJSONPRequests) {\n                retries.push(var3);\n            }\n        } while (var3 < dataOnOffConfig.retryFaliledJSONPRequests);\n        retries.push(dataOnOffConfig.retryFaliledJSONPRequests);\n        // console.debug(\"Retries at \" + retries);\n        return retries;\n    }\n\n    function validDataOnOffConfig(dataOnOffConfig) {\n        if (typeof dataOnOffConfig !== 'object') {\n            console.error(\"DataOnOff configuration must be provided\");\n            return false;\n        }\n        if (typeof dataOnOffConfig.serverUrl !== 'string') {\n            console.error(\"DataOnOff server url must be provided\");\n            return false;\n        }\n\n        if (typeof dataOnOffConfig.deviceId !== 'object') {\n            if (typeof window.device === 'object') {\n                if ((typeof window.device.uuid === 'string') && (window.device.uuid !== '')) {\n                    dataOnOffConfig.deviceId = {\n                        deviceId : window.device.uuid\n                    };\n                }\n            }\n            if (typeof dataOnOffConfig.deviceId !== 'object') {\n                console.error(\"DataOnOff deviceId must be provided\");\n                return false;\n            }\n        }\n        if (typeof dataOnOffConfig.onChangesCallback !== 'function') {\n            console.error(\"ChangesCallback should be declared\");\n            return false;\n        }\n        if (typeof dataOnOffConfig.storeVersionNumber !== 'function') {\n            console.error(\"storeVersionNumber should be declared\");\n            return false;\n        }\n        if (typeof dataOnOffConfig.getVersionNumber !== 'function') {\n            console.error(\"getVersionNumber should be declared\");\n            return false;\n        }\n        if (typeof dataOnOffConfig.retryFaliledJSONPRequests !== 'number') {\n            console.info(\"Assuming 5 minutes for retrying JSONP requests.\");\n            dataOnOffConfig.retryFaliledJSONPRequests = 60 * 60 * 1000;\n        }\n        if (typeof dataOnOffConfig.onFatalError !== 'function') {\n            dataOnOffConfig.onFatalError = function(msg) {\n                console.error(msg);\n            };\n        }\n        // Schedule server synchronization\n        if ( (typeof dataOnOffConfig.scheduleServerSyncPeriod !== 'number') || (dataOnOffConfig.scheduleServerSyncPeriod <= 0)) {\n            console.warn(\"dataOnOffConfig.scheduleServerSyncPeriod should be an integer value greater than zero.  \"+\n            \t\t     \"Disabling periodical server syncs.\");\n            dataOnOffConfig.scheduleServerSyncPeriod = undefined;\n        }\n\n        return true;\n    }\n\n    function scheduleServerSync(period, event, state) {\n        var timeoutId = undefined;\n        function periodicSync() {\n            timeoutId = window.setTimeout(function() {\n                if (!state.isIdle()) {\n                    // console.debug('Already doing other things. Skipping server sync');\n                } else {\n                    // console.debug('Executing scheduled sync');\n                    self.manualServerSynchronization();\n                }\n                periodicSync();\n            }, period);\n        }\n\n        // When we receive changes from the server, schedule a newer synchronization\n        event.serverSync.addEventListener(function() {\n            window.clearTimeout(timeoutId);\n            periodicSync();\n        });\n    }\n};\n\nmodule.exports = DataOnOff;\n});\n\n//@ sourceURL=lib/DataOnOff.js")} catch(e) {console.log("exception: in lib/DataOnOff.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/DBQueue\", function(require, exports, module) {\n/**\n * DBQueue.js A function to represent a persistent queue\n */\nvar DBQueue = function (dataOnOffConfig, event, state, retries) {\n\n    // Database storage\n    var db = undefined;\n    // Queue items consumer\n    var consumer = undefined;\n    // Timeout retry consume queue items\n    var timeoutId = undefined;\n    // Retry count\n    var retryCnt = 0;\n\n    initQueue(dataOnOffConfig);\n\n    function initQueue(dataOnOffConfig) {\n        if (typeof dataOnOffConfig.db === 'object') {\n            db = dataOnOffConfig.db;\n            console.info(\"DataOnOff is using provided database\");\n        } else {\n            db = window.openDatabase('dataonoff', '1.0', \"DataOnOff operations\", 1024 * 1024);\n        }\n        populateDatabase(db);\n\n        if (db === null) {\n            console.error('Cannot open DBQueue database');\n        } else {\n            // console.debug('DBQueue database version \\'' + db.version + '\\' opened');\n        }\n\n        console.info('DBQueue initialized.');\n    }\n\n    function populateDatabase(db) {\n        db.transaction(function(tx) {\n            tx.executeSql('SELECT COUNT(*) FROM OPERATIONS', [], undefined, function(tx, e) {\n                createTables(tx);\n            });\n        });\n    }\n\n    function createTables(tx) {\n        // console.debug('DBQueue creating table OPERATIONS ...');\n        var sql = 'CREATE TABLE IF NOT EXISTS OPERATIONS ' +\n                  '(id INTEGER PRIMARY KEY AUTOINCREMENT, data TEXT)';\n        tx.executeSql(sql, [], function(tx, rs) {\n            // console.debug('DBQueue ... created table OPERATIONS');\n        }, function(e) {\n            console.error('DBQueue error creating table OPERATIONS: ' + e.code + ' ' + e.message);\n        });\n    }\n\n    /**\n     * Sets queue items consumer\n     */\n    this.setConsumer = function(_consumer) {\n        consumer = _consumer;\n        event.consumerReady.addEventListener(this.consumeQueueItems);\n    };\n\n    /**\n     * Enqueues the specified item. The parameter is: item - the item to enqueue\n     */\n    this.enqueue = function(item) {\n        // console.debug(\"DBQueue.enqueue: \" + item);\n\n        var self = this;\n        db.transaction(function insert(tx) {\n            tx.executeSql('INSERT INTO OPERATIONS(data) VALUES(?)', [ item ], function(tx, r) {\n                // After storing the item, try to consume it immediately\n                self.consumeQueueItems();\n            }, function(tx, e) {\n                console.error('DBQueue.enqueue error: ' + e.code + ' ' + e.message);\n            });\n        });\n    };\n    /**\n     * Consume all queue items.\n     */\n    this.consumeQueueItems = function() {\n        if (state.isRetrying()) {\n            clearConsumeQueueItemsRetry();\n        }\n        if (!state.isSending()) {\n            state.sending();\n            _consumeQueueItems();\n        } else {\n            // console.debug(\"Already consuming queue items\");\n        }\n    };\n\n    function clearConsumeQueueItemsRetry() {\n        // console.debug('Canceling retry: ' + timeoutId);\n        window.clearTimeout(timeoutId);\n        state.idle();\n    }\n\n    function _consumeQueueItems() {\n        db.transaction(function(tx) {\n            // Read head queue item\n            var sql = 'SELECT id, data FROM OPERATIONS ORDER BY ID LIMIT 1';\n            tx.executeSql(sql, [], function(tx, results) {\n                if (results.rows.length === 0) {\n                    state.idle();\n                    fireOnEmptyQueue();\n                } else {\n                    var id = results.rows.item(0).id;\n                    var data = results.rows.item(0).data;\n                    consumeQueueItem(id, data);\n                }\n            }, function(tx, e) {\n                state.error();\n                dataOnOffConfig.onFatalError(\"DBQueue consumeQueueItems error: \" + e.code + ' ' +\n                          e.message);\n            });\n        });\n        function consumeQueueItem(id, data) {\n            consumer.consume(data, function(operation, response) {\n                onItemConsumed();\n                // console.debug('Item consumed ' + JSON.stringify(response) + ' ,response: '\n                // + JSON.stringify(response));\n            }, function() {\n                state.retrying();\n                timeoutId = window.setTimeout(function() {\n                    // console.debug('Retry: ' + retryCnt);\n                    _consumeQueueItems();\n                }, retryTimeout(retryCnt++));\n            });\n\n            function retryTimeout(retryCnt) {\n                if (retryCnt < retries.length) {\n                    return retries[retryCnt];\n                } else {\n                    return retries[retries.length - 1];\n                }\n            }\n\n            function onItemConsumed() {\n                retryCnt = 0;\n                removeItem(id, function() {\n                    // Consume next queue item\n                    _consumeQueueItems();\n                }, function(msg) {\n                    state.error();\n                    dataOnOffConfig.onFatalError(msg);\n                });\n            }\n        }\n\n        function removeItem(id, onSuccess, onFailure) {\n            db.transaction(function(tx) {\n                // console.debug('DBQueue removing item #' + id);\n                var sql = 'DELETE FROM OPERATIONS WHERE id = ?';\n                tx.executeSql(sql, [ id ], onSuccess, function(tx, e) {\n                    onFailure(\"DBQueue removeItem error: \" + e.code + ' ' + e.message);\n                });\n            });\n        }\n\n        function fireOnEmptyQueue() {\n            // console.debug('DBQueue - consumed all items');\n            consumer.onEmptyQueue();\n        }\n    }\n};\n\nmodule.exports = DBQueue;\n});\n\n//@ sourceURL=lib/common/DBQueue.js")} catch(e) {console.log("exception: in lib/common/DBQueue.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/DataOnOffServer\", function(require, exports, module) {\nvar JSONP = require(\"dataonoff/JSONP\");\n\nvar DataOnOffServer = function (dataOnOffConfig, event, state) {\n    var serverIsOnLine = undefined;\n    var remoteUrlServer = dataOnOffConfig.serverUrl;\n    var deviceId = JSON.stringify(dataOnOffConfig.deviceId);\n    var getVersionNumber = dataOnOffConfig.getVersionNumber;\n    var storeVersionNumber = dataOnOffConfig.storeVersionNumber;\n    var onLineNetwork = undefined;\n\n    event.onLineNetwork.addEventListener(function() {\n        onLineNetwork = true;\n    });\n    event.offLineNetwork.addEventListener(function() {\n        onLineNetwork = false;\n        setOffLine();\n    });\n\n    this.deliverOperationToServer = function(operation, onDeliveredOperation, onUnavailableServer) {\n        // console.debug('deliverOperationToServer sending operation: ' + JSON.stringify(operation));\n        var url = remoteUrlServer + '/processOperation';\n        var params = {\n            operation : JSON.stringify(operation),\n            deviceId : deviceId\n        };\n        if (onLineNetwork === false) {\n            jsonpComunicationsFailure();\n        } else {\n            JSONP.get(url, params, function(response) {\n                setOnLine();\n                //console.info('operation: ' + JSON.stringify(operation) + ' procesed. response: ' +\n                //        JSON.stringify(response));\n                onDeliveredOperation(operation, response);\n            }, function() {\n                jsonpComunicationsFailure();\n            });\n        }\n\n        function jsonpComunicationsFailure() {\n            console.warn('DataOnOffServer unavailable. deliverOperationToServer:' + serverIsOnLine +\n                    ', ' + JSON.stringify(params));\n            setOffLine();\n            onUnavailableServer();\n        }\n    };\n\n    this.reciveChangesFromServer = function(reciveChangesCallback, onUnavailableServer) {\n        state.receiving();\n        var url = remoteUrlServer + '/getDataForMobileDevice';\n        var params = {\n            deviceId : deviceId,\n            version : getVersionNumber()\n        };\n        JSONP.get(url, params, function(changes) {\n            setOnLine();\n            if (typeof changes !== 'undefined') {\n                //console.info('DataOnOff.reciveChangesFromServer: ' + JSON.stringify(changes));\n                reciveChangesCallback(changes);\n                storeVersionNumber(changes.versionNumber);\n            } else {\n                // console.debug('DataOnOff.reciveChangesFromServer: no changes needed');\n            }\n            state.idle();\n        }, function() {\n            console.warn('DataOnOffServer unavailable. reciveChangesFromServer:' +\n                    JSON.stringify(params) + \". Forcing synchronization\");\n            setOffLine();\n            state.idle();\n            onUnavailableServer();\n        });\n    };\n\n    function setOnLine() {\n        if ((typeof serverIsOnLine === 'undefined') || (!serverIsOnLine)) {\n            serverIsOnLine = true;\n            event.onLineServer.fireEvent();\n        }\n    }\n\n    function setOffLine() {\n        if ((typeof serverIsOnLine === 'undefined') || serverIsOnLine) {\n            serverIsOnLine = false;\n            event.offLineServer.fireEvent();\n        }\n    }\n};\n\nmodule.exports = DataOnOffServer;\n\n});\n\n//@ sourceURL=lib/common/DataOnOffServer.js")} catch(e) {console.log("exception: in lib/common/DataOnOffServer.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/DataOnOffState\", function(require, exports, module) {\nvar DataOnOffState = function (event) {\n    var IDLE = 0, SENDING = 1, RECEIVING = 2, RETRYING = 3, ERROR = -1;\n\n    var currentstate = undefined;\n\n    this.error = function() {\n        if (currentstate !== ERROR) {\n            currentstate = ERROR;\n        }\n    };\n    this.isError = function() {\n        return currentstate === ERROR;\n    };\n    this.idle = function() {\n        if (currentstate !== IDLE) {\n            currentstate = IDLE;\n            // console.debug(\"currentstate: IDLE\");\n            event.idle.fireEvent();\n        }\n    };\n    this.isIdle = function() {\n        return currentstate === IDLE;\n    };\n    this.sending = function() {\n        if (currentstate !== SENDING) {\n            currentstate = SENDING;\n            // console.debug(\"currentstate: SENDING\");\n            event.sending.fireEvent();\n        }\n    };\n    this.isSending = function() {\n        return currentstate === SENDING;\n    };\n    this.receiving = function() {\n        if (currentstate !== RECEIVING) {\n            currentstate = RECEIVING;\n            // console.debug(\"currentstate: RECEIVING\");\n            event.receiving.fireEvent();\n        }\n    };\n    this.isReceiving = function() {\n        return currentstate === RECEIVING;\n    };\n    this.retrying = function() {\n        if (currentstate !== RETRYING) {\n            currentstate = RETRYING;\n            // console.debug(\"currentstate: RETRYING\");\n            event.retrying.fireEvent();\n        }\n    };\n    this.isRetrying = function() {\n        return currentstate === RETRYING;\n    };\n};\n\nmodule.exports = DataOnOffState;\n\n});\n\n//@ sourceURL=lib/common/DataOnOffState.js")} catch(e) {console.log("exception: in lib/common/DataOnOffState.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/EventHandler\", function(require, exports, module) {\nvar EventHandler = function (event) {\n    var handlers = [];\n\n    this.addEventListener = function(handler) {\n        if (typeof handler === 'function') {\n            // console.debug('Registered new handler for events of type ' + event);\n            handlers.push(handler);\n        }\n    };\n    this.fireEvent = function(params) {\n        var handlerParams = [];\n        for ( var i = 0; i < arguments.length; i++) {\n            handlerParams.push(arguments[i]);\n        }\n\n        // console.debug('Firing event of type ' + event\n        // + (typeof params !== 'undefined' ? ' params:' + JSON.stringify(handlerParams) : ''));\n\n        for ( var j = 0; j < handlers.length; j++) {\n            handlers[j].apply(this, handlerParams);\n        }\n    };\n};\n\nmodule.exports = EventHandler;\n\n});\n\n//@ sourceURL=lib/common/EventHandler.js")} catch(e) {console.log("exception: in lib/common/EventHandler.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/JSONP\", function(require, exports, module) {\n/**\n * Usage example: <code>\n *  var url = 'http://blog.eood.cn/api';\n *  var error = function() {\n *      alert('error');\n *  };\n *  var success = function(data) {\n *    // process the data\n *  };\n *  JSONP.get( url, {'parm1': 'parm1_value', 'parm2': 'parm2_value'}, success, error);\n </code>\n */\nvar JSONP = (function(global) {\n    var counter = 0, head = false, window = global;\n\n    function load(url, error) {\n        // console.debug(\"JSONP.load \" + url);\n        var script = document.createElement('script');\n        var done = false;\n        script.src = url;\n        script.async = true;\n\n        script.onload = script.onreadystatechange = function() {\n            var readyState = (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\");\n            if (!done && readyState) {\n                done = true;\n                script.onload = script.onreadystatechange = null;\n                if (script && script.parentNode) {\n                    script.parentNode.removeChild(script);\n                }\n            }\n        };\n        script.onerror = function() {\n            // call the error callback\n            error();\n        };\n        if (!head) {\n            head = document.getElementsByTagName('head')[0];\n        }\n        head.appendChild(script);\n    }\n\n    function jsonp(url, params, callback, error) {\n        var query = \"?\";\n        params = params || {};\n        for ( var key in params) {\n            if (params.hasOwnProperty(key)) {\n                query += encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]) + \"&\";\n            }\n        }\n        var _jsonp = \"json\" + (++counter);\n        window[_jsonp] = function(data) {\n            callback(data);\n            try {\n                delete window[_jsonp];\n            } catch (e) {\n            }\n            window[_jsonp] = null;\n        };\n\n        var errorCalled = false;\n        function fireErrorCallback() {\n            if (!errorCalled) {\n                errorCalled = true;\n                if (typeof error === 'function') {\n                    error();\n                }\n            }\n        }\n\n        load(url + query + \"callback=\" + _jsonp + '&random=' + Math.random(), fireErrorCallback);\n\n        window.setTimeout(function() {\n            if (typeof window[_jsonp] == \"function\") {\n\n                // replace success with null callback in case the request is just very latent.\n                window[_jsonp] = function(data) {\n                    try {\n                        delete window[_jsonp];\n                    } catch (e) {\n                    }\n                    window[_jsonp] = null;\n                };\n\n                // call the error callback\n                fireErrorCallback();\n\n                // set a longer timeout to safely clean up the unused callback.\n                window.setTimeout(function() {\n                    if (typeof window[_jsonp] == \"function\") {\n                        try {\n                            delete window[_jsonp];\n                        } catch (e) {\n                        }\n                        window[_jsonp] = null;\n                    }\n                }, 120000);\n            }\n        }, 10000);\n\n        return jsonp;\n    }\n    return {\n        get : jsonp\n    };\n}(this));\n\nmodule.exports = JSONP;\n});\n\n//@ sourceURL=lib/common/JSONP.js")} catch(e) {console.log("exception: in lib/common/JSONP.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/OperationsConsumer\", function(require, exports, module) {\nvar DataOnOffServer = require('dataonoff/DataOnOffServer');\n\nvar OperationsConsumer = function (dataOnOffConfig, event, state, dataOnOff) {\n    var server = new DataOnOffServer(dataOnOffConfig, event, state);\n    var onChangesCallback = dataOnOffConfig.onChangesCallback;\n\n    event.onLineNetwork.addEventListener(function() {\n        event.consumerReady.fireEvent();\n    });\n\n    this.consume = function(item, onProcessOperation, onTimeout) {\n        // console.debug('Consuming operation: ' + item);\n        var operation = JSON.parse(item);\n        server.deliverOperationToServer(operation, function(operation, response) {\n            onProcessOperation(operation, response);\n            event.processedOperation.fireEvent(operation, response);\n        }, onTimeout);\n    };\n\n    this.onEmptyQueue = function() {\n        if (typeof onChangesCallback === 'function') {\n            // console.debug('Receiving changes from server ...');\n            server.reciveChangesFromServer(function onSuccess(serverChanges) {\n                if (serverChanges) {\n                    var currentVersion = dataOnOffConfig.getVersionNumber();\n                    if (serverChanges.mobileVersionNumber === currentVersion) {\n                        var changes = serverChanges.changes;\n                        if (changes) {\n                            onChangesCallback(changes);\n                            event.serverSync.fireEvent();\n                        }\n                    } else {\n                        console.warn(\"Changes version received from the server (\" +\n                                     serverChanges.mobileVersionNumber +\n                                     \") doesn't match current version: \" + currentVersion);\n                        // Request a new sync\n                        dataOnOff.manualServerSynchronization();\n                    }\n                }\n            }, function onFailure() {\n                dataOnOff.manualServerSynchronization();\n            });\n            // console.debug('... received changes from server');\n        } else {\n            console.warn('onChangesCallback: ' + typeof onChangesCallback);\n        }\n    };\n};\n\nmodule.exports = OperationsConsumer;\n});\n\n//@ sourceURL=lib/common/OperationsConsumer.js")} catch(e) {console.log("exception: in lib/common/OperationsConsumer.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/builder\", function(require, exports, module) {\nfunction each(objects, func, context) {\n    for (var prop in objects) {\n        if (objects.hasOwnProperty(prop)) {\n            func.apply(context, [objects[prop], prop]);\n        }\n    }\n}\n\nfunction include(parent, objects, clobber, merge) {\n    each(objects, function (obj, key) {\n        try {\n          var result = obj.path ? require(obj.path) : {};\n\n          if (clobber) {\n              // Clobber if it doesn't exist.\n              if (typeof parent[key] === 'undefined') {\n                  parent[key] = result;\n              } else if (typeof obj.path !== 'undefined') {\n                  // If merging, merge properties onto parent, otherwise, clobber.\n                  if (merge) {\n                      recursiveMerge(parent[key], result);\n                  } else {\n                      parent[key] = result;\n                  }\n              }\n              result = parent[key];\n          } else {\n            // Overwrite if not currently defined.\n            if (typeof parent[key] == 'undefined') {\n              parent[key] = result;\n            } else if (merge && typeof obj.path !== 'undefined') {\n              // If merging, merge parent onto result\n              recursiveMerge(result, parent[key]);\n              parent[key] = result;\n            } else {\n              // Set result to what already exists, so we can build children into it if they exist.\n              result = parent[key];\n            }\n          }\n\n          if (obj.children) {\n            include(result, obj.children, clobber, merge);\n          }\n        } catch(e) {\n          console.error('Exception building cordova JS globals: ' + e + ' for key \"' + key + '\"');\n        }\n    });\n}\n\n/**\n * Merge properties from one object onto another recursively.  Properties from\n * the src object will overwrite existing target property.\n *\n * @param target Object to merge properties into.\n * @param src Object to merge properties from.\n */\nfunction recursiveMerge(target, src) {\n    for (var prop in src) {\n        if (src.hasOwnProperty(prop)) {\n            if (typeof target.prototype !== 'undefined' && target.prototype.constructor === target) {\n                // If the target object is a constructor override off prototype.\n                target.prototype[prop] = src[prop];\n            } else {\n                target[prop] = typeof src[prop] === 'object' ? recursiveMerge(\n                        target[prop], src[prop]) : src[prop];\n            }\n        }\n    }\n    return target;\n}\n\nmodule.exports = {\n    build: function (objects) {\n        return {\n            intoButDontClobber: function (target) {\n                include(target, objects, false, false);\n            },\n            intoAndClobber: function(target) {\n                include(target, objects, true, false);\n            },\n            intoAndMerge: function(target) {\n                include(target, objects, true, true);\n            }\n        };\n    }\n};\n\n});\n\n//@ sourceURL=lib/common/builder.js")} catch(e) {console.log("exception: in lib/common/builder.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/changes/ChangesFromServerProcessor\", function(require, exports, module) {\nvar DataChangesFormServerProcessor = require('dataonoff/changes/DataChangesFormServerProcessor');\n\nvar ChangesFromServerProcessor = function () {\n    this.changesProcessor = new DataChangesFormServerProcessor();\n};\n\nChangesFromServerProcessor.prototype.onChanges = function(changes) {\n    this.changesProcessor.onDataChanges(changes);\n};\n\nmodule.exports = ChangesFromServerProcessor;\n\n});\n\n//@ sourceURL=lib/common/changes/ChangesFromServerProcessor.js")} catch(e) {console.log("exception: in lib/common/changes/ChangesFromServerProcessor.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/changes/DataChangesFormServerProcessor\", function(require, exports, module) {\nvar DataChangesFormServerProcessor = function() {\n    this.entitiesHandler = {};\n};\n\nDataChangesFormServerProcessor.prototype.addEntityHandler = function(entity, handler) {\n    this.entitiesHandler[entity] = handler;\n};\n\nDataChangesFormServerProcessor.prototype.onDataChanges = function(dataChanges) {\n    for ( var i = 0; i < dataChanges.length; i++) {\n        var dataChange = dataChanges[i];\n        if (dataChange) {\n            this.onDataChange(dataChange);\n        }\n    }\n};\n\nDataChangesFormServerProcessor.prototype.onDataChange = function(dataChange) {\n\t//console.debug(\"Handling dataChange: \" + JSON.stringify(dataChange));\n\t\n    var entity = dataChange.entity;\n    var entityHandler = this.entitiesHandler[entity];\n    if (entityHandler) {\n        var entityOperationHandler = entityHandler[dataChange.action];\n        if (typeof entityOperationHandler === 'function') {\n        \tentityOperationHandler(dataChange);\n        } else {\n        \tconsole.warn('Unknown operation entity handler.  Operation:' + dataChange.action + \n        \t\t\t     ', Entity: ' + entity + \n        \t\t\t     ', entityOperationHandler: ' + entityOperationHandler);\n        }\n    } else {\n    \tconsole.warn('You must declare an entityHandler for entity ' + entity  + \n    \t\t\t     ', dataChange: '+ JSON.stringify(dataChange));\n    }\n};\n\nmodule.exports = DataChangesFormServerProcessor;\n});\n\n//@ sourceURL=lib/common/changes/DataChangesFormServerProcessor.js")} catch(e) {console.log("exception: in lib/common/changes/DataChangesFormServerProcessor.js: " + e);console.log(e.stack);}
try {eval("define(\"dataonoff/common\", function(require, exports, module) {\nmodule.exports = {\n    objects: {\n        DataOnOff: {\n            path: 'dataonoff'\n        },\n        ChangesFromServerProcessor : {\n            path: 'dataonoff/changes/ChangesFromServerProcessor'\n        },\n        DataChangesFormServerProcessor : {\n            path: 'dataonoff/changes/DataChangesFormServerProcessor'\n        }\n    }\n};\n\n});\n\n//@ sourceURL=lib/common/common.js")} catch(e) {console.log("exception: in lib/common/common.js: " + e);console.log(e.stack);}
try {eval("(function (context) {\n    var base = require('dataonoff/common'),\n        builder = require('dataonoff/builder');\n\n    // Drop the common globals into the window object, but be nice and don't overwrite anything.\n    builder.build(base.objects).intoButDontClobber(context);\n\n}(this));\n\n//@ sourceURL=lib/scripts/bootstrap.js")} catch(e) {console.log("exception: in lib/scripts/bootstrap.js: " + e);console.log(e.stack);}

})();